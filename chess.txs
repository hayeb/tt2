-- TorXakis Model for the Lichess Chess application.
-- Authors: Denisa _, Rick Erckens, Haye Bohm

-- ----------------------------------------------------------------------------------------- --
-- Data

TYPEDEF ChessState ::= Int
ENDDEF

TYPEDEF ChessStates ::= Nil | Cons  { hd ::  ChessState
                              ; tl ::  ChessStates
                              }
ENDDEF

-- add f to end of b
FUNCDEF addToEnd (b :: ChessStates; f :: ChessStates) :: ChessStates
    ::= IF isNil(f)
        THEN b
        ELSE
            IF isNil(b)
            THEN f
            ELSE Cons(hd(b), addToEnd(tl(b), f))
            FI
        FI
ENDDEF

FUNCDEF getLast(l :: ChessStates) :: ChessState
	::= IF isNil(tl(l))
		THEN hd(l)
		ELSE getLast(tl(l))
		FI
ENDDEF

-- add f to begin of b --
FUNCDEF addToBegin (b :: ChessStates; f:: ChessStates) :: ChessStates
    ::= addToEnd(f, b)
ENDDEF

TYPEDEF ChessCommand ::= Move | Back | BackStep | Forward | ForwardStep | Flip | Resign | TakeBack
ENDDEF

-- ----------------------------------------------------------------------------------------- --
PROCDEF movePiece [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates; current :: ChessState)
::=
	Command ! Move >-> Response ? resp >-> chessLoop [Response, Command] (addToEnd(back, Cons(resp, Nil)), Nil, resp)
ENDDEF

PROCDEF backward [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates; current :: ChessState)
::=
    Command ! Back >-> Response ? resp [[ resp == hd(back) ]] >-> chessLoop [Response, Command] ( Nil, addToBegin(Cons(current, forward), back), resp)
ENDDEF

PROCDEF backwardStep [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates; current :: ChessState)
::=
     Command ! BackStep >-> Response ? resp [[ resp == getLast(back) ]] >-> chessLoop [Response, Command] (addToEnd(back, Cons(current, Nil)), Cons(current, forward), resp)
ENDDEF

PROCDEF forward [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates; current :: ChessState)
::=
     Command ! Forward >-> Response ? resp [[resp == getLast(forward)]] >-> chessLoop [Response, Command] (addToEnd(addToEnd(back, Cons(current, Nil)), forward), Nil, resp)
ENDDEF

PROCDEF forwardStep [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates; current :: ChessState)
::=
    Command ! ForwardStep >-> Response ? resp [[resp == hd(forward)]] >-> chessLoop [Response, Command] (addToEnd(back, Cons(current, Nil)), tl(forward), resp)
ENDDEF

PROCDEF chessLoop [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates; current :: ChessState)
::=
        [[isNil(back) /\ isNil(forward)]] =>> movePiece [Response, Command] (back, forward, current)
     ##
        [[isNil(back) /\ not(isNil(forward))]] =>> (
                forward [Response, Command] (back, forward, current)
            ##
                forwardStep [Response, Command] (back, forward, current)
        )
	 ##
		[[isNil(forward) /\ not(isNil(back))]] =>> (
				movePiece [Response, Command] (back, forward, current)
	        ##
	            backward [Response, Command] (back, forward, current)
	        ##
	            backwardStep [Response, Command] (back, forward, current)
	    )
     ##
        [[not(isNil(back)) /\ not(isNil(forward))]] =>> (
                backward [Response, Command] (back, forward, current)
            ##
                backwardStep [Response, Command] (back, forward, current)
            ##
                forward [Response, Command] (back, forward, current)
            ##
                forwardStep [Response, Command] (back, forward, current)
        )
ENDDEF

-- ----------------------------------------------------------------------------------------- --


CHANDEF Channels ::=
    Command :: ChessCommand ; Response :: ChessState
ENDDEF


MODELDEF LiChess ::=
    CHAN IN    Command
    CHAN OUT   Response

    BEHAVIOUR
		Response ? resp >-> chessLoop [Response, Command] (Nil, Nil, response)
ENDDEF

-- ----------------------------------------------------------------------------------------- --

CNECTDEF  Sut ::=
        CLIENTSOCK

        CHAN OUT Command 					HOST "localhost" PORT 7890
		ENCODE Command ? cmd				-> ! toString (cmd)
		
		CHAN IN Response					HOST "localhost" PORT 7890
		DECODE 	Response ! fromString(s)	<- ? s
ENDDEF

-- ----------------------------------------------------------------------------------------- --
--                                                                                           --
-- ----------------------------------------------------------------------------------------- --
