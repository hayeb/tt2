-- TorXakis Model for the Lichess Chess application.
-- Authors: Denisa _, Rick Erckens, Haye Bohm

-- ----------------------------------------------------------------------------------------- --
-- Data

TYPEDEF ChessState ::= Int
ENDDEF

TYPEDEF ChessStates ::= Nil | Cons  { hd ::  ChessState
                              ; tl ::  ChessStates
                              }
ENDDEF
							  
FUNCDEF  add ( x :: ChessState; l :: ChessStates ) :: ChessStates
         ::= IF    isNil(l)
             THEN  Cons(x,Nil)
             ELSE  Cons(hd(l),add(x,tl(l)))
             FI
ENDDEF

TYPEDEF ChessCommand ::= Move | Back | BackStep | Forward | ForwardStep | Flip | Resign | TakeBack
ENDDEF

-- ----------------------------------------------------------------------------------------- --
{- Send the move command to the SUT -}
PROCDEF movePiece [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates)
::=
	Command ! Move >-> Response ?resp >-> chessLoop [Response, Command] (Cons(resp, back), forward)
ENDDEF

PROCDEF back [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates)
::=
ENDDEF

PROCDEF backStep [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates)
::=
ENDDEF

PROCDEF forward [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates)
::=
ENDDEF

PROCDEF forwardStep [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates)
::=
ENDDEF

PROCDEF chessLoop [Response :: ChessState; Command :: ChessCommand] (back :: ChessStates; forward :: ChessStates)
::=
    IF isNil(back) /\ isNil(forward) THEN
        movePiece [Response, Command] (back, forward)
    ELSE
        IF isNil(back) THEN (
                forward [Response, Command] (back, forward)
            ##
                forwardStep [Response, Command] (back, forward)
            )
        ELSE
            IF isNil(forward) THEN (
                    movePiece [Response, Command] (back, forward)
                ##
                    backward [Response, Command] (back, forward)
                ##
                    backwardStep [Response, Command] (back, forward)
                    -- Maybe also add the other options: Resign, takeback? --
               )
            ELSE (
                    movePiece [Response, Command] (back, forward)
                ##
                    backward [Response, Command] (back, forward)
                ##
                    backwardStep [Response, Command] (back, forward)
                ##
                    forward [Response, Command] (back, forward)
                ##
                    forwardStep [Response, Command] (back, forward)
            )
            FI
        FI
    FI
ENDDEF





-- ----------------------------------------------------------------------------------------- --


CHANDEF Channels ::=
    Command :: ChessCommand ; Response :: ChessState
ENDDEF


MODELDEF LiChess ::=
    CHAN IN    Command
    CHAN OUT   Response

    BEHAVIOUR
		movePiece [Response, Command] (Nil, Nil)
ENDDEF

-- ----------------------------------------------------------------------------------------- --

CNECTDEF  Sut ::=
        CLIENTSOCK

        CHAN OUT Command 					HOST "localhost" PORT 7890
		ENCODE Command ? cmd				-> ! toString (cmd)
		
		CHAN IN Response					HOST "localhost" PORT 7890
		DECODE 	Response ! fromString(s)	<- ? s
ENDDEF

-- ----------------------------------------------------------------------------------------- --
--                                                                                           --
-- ----------------------------------------------------------------------------------------- --
